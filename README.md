توصيف الحالة:
هي رقعه أبعادها n*n وتكون رقعة اللعبة عباره عن List تحوي  Listsبعدد n تعبر عن أسطر الرقعة حيث كل سطر يحوي n عنصر هي قطع اللعب التي تكون عبارة عن عدة أنواع:  قطع حمراء وقطع بنفسجية وقطع رمادية ويوجد اماكن فارغة بالرقعة يمكن تحريك القطع إليها وهي عباره عن نوعين: أماكن فارغة وأماكن تتميز بحلقة بيضاء هي مواقع الحل.

فضاء الحالات: generate_possible_moves
الفكرة أنه يتم عمل مسح كامل للرقعة ونأخذ احداثيات القطع الحمراء والبنفسجية ونقوم بحفظها ضمن list بعد ذلك من أجل قطعة من هذه القطع حمراء أو بنفسجية يتم عمل مسح للرقعة كامله وأخذ المواقع التي يمكن تحريك هذه القطعة اليها ويتم حفظها في list وذلك حسب شروط اللعبة ويعيد هذا التابع  listتحوي الأماكن التي يمكن الانتقال إليها لكل قطعة حمراء أو بنفسجية  والتي تعبرعن فضاء الحالات للرقع الأساسية.

الحالة الابتدائية:
 هي عبارة عن رقعة من اللعبة تحوي مجموعه أحجار موزعة على الرقعة بشكل عشوائي وتكون الأحجار عبارة عن عدة ألوان كل لون يعبر عن دلالة معينه للرقعة الأحمر: هو مغناطيس يجذب القطعة الحديدية خطوة.
 البنفسجي: هو مغناطيس ينفر القطعة الحديدية خطوه.
 الرمادي: هو قطعة حديدية لا يمكن تحريكها إلا بتأثير من القطع الحمراء أو البنفسجية.
 يوجد أيضا مواقع فارغة ومواقع تحوي حلقات بيضاء هذه المواقع هي التي يمكن للقطع الحمراء او البنفسجية الانتقال إليها 
والفكرة أن المواقع التي تحوي حلقات بيضاء يجب ان تكون مساويه لعدد القطع الكلية في الرقعة لنكون قادرين على الوصول الى حالة نهائية فيما بعد حسب شروط اللعبة.

العمليات والإجراءات:
 بداية يوجد في LogicMagnetsUI (Class) تابع اللعب play حيث يبدأ تنفيذ اللعبة عند استدعائه في تابع main ويأخذ الرقعة الابتدائية ك parameter.
 الفكرة من التابع انه يدخل في حلقة تنكسر عند الوصول الى حل نهائي والوصول الى الحالة النهائية يكون عن طريق تابع check_final_solution الذي يرجع True في حال كانت target_positions تحوي قيمة
 تابع initialize_game  يقوم بحساب عدد القطع من كل نوع وضمنه نقوم بعمل  objectمن class الذي يعبر عن منطق اللعبة ونقوم بتمرير المعلومات التي حصلنا عليها من تابع initialize_game الى constractor الخاص ب class LogicMagnetsGame  الفكرة أننا نقوم بتخزين target_positions في list  وذلك باستدعاء تابع initialize_board الذي يعيد إحداثيات target_positions في الرقعة التي يتم إدخالها ضمن list.
الآن في تابع play يتم استدعاء تابع get_user_move الذي يعيد موقع القطعة الذي يريد اللاعب تحريكها والموقع الذي يريد التحريك إليه ويتم حفظها في متغيرات ثم نستخدمها بحيث نمررها للتابع الذي يقوم بالتحريك.
تابع move_piece وظيفته القيام بتحريك القطعة وذلك حسب شروط اللعبة ويوجد أيضا تابع can_move الذي يتحقق من إمكانية التحرك إلى الموقع ويتم استدعاؤه داخل تابع move_piece.
تابع attract_gray_pieces يقوم بالتحقق من السطر والعمود للموقع الذي تم تحريك القطعة الحمراء إليه ويطبق تأثيرها عن طريق تابع move_gray_piece.

تابع push_gray_pieces يقوم بالتحقق من السطر والعمود الذي تم الذي تم تحريك القطعة البنفسجية إليه ويطبق تأثير القطعة عن طريق تابع move_gray_piece.
تابع move_gray_piece يقوم بتطبيق تأثير الجذب او التنافر.
الحالة النهائية يتم الوصول إليها عندما تكون جميع target_positions تحوي قيمة بغض النظرعن نوع القطعة.
وذلك لأن شرط الفوز في اللعبة هو أن تكون جميع القطع موجوده في target_positions.

                                                                                                                                                                          BFS:
بنية المعطيات: deque
الية الحل: يتم تخزين الحالة الابتدائية ببنية المعطيات ثم نستخدم حلقة while تستمر طالما ال deque يحوي قيم، 
الفكرة هي أننا نقوم بالإضافة لل deque من اليمين لأننا نحتاج للمرور على الحالات level by level لذلك نقوم بعمل pop من اليسار عن طريق تابع popleft ونقوم بحفظ الرقعة في object (قمت أنا بحفظ الرقعة وال path حيث بداية يكون ال path عبارة عن list فارغة) 
بعد ذلك نقوم بجلب الحالات الممكنة عن طريق تابع generate_possible_moves الذي يقوم بإعادة الموقع القديم والموقع الجديد 
نقوم بالمرور على الحالات الممكنة ونطبق الانتقال ثم نتحقق في حال لم تكن الحالة ضمن مصفوفة visited نقوم بإضافتها إليها وإلى deque مع ال path الخاص بها الذي هو عبارة عن path القديم بالإضافة الى move الذي قمنا به 
الحل: يقوم التابع solve_bfs بإعادة ال path الخاص بالحلول التي تم الوصول إليها ضمن list نستفيد منها في طباعة الحلول 
                                                                                                                                                                                                                                                                                                                                                        DFS:
بنية المعطيات: stack 
الية الحل: مشابهة تماما لآلية الحل في BFS لكن الفرق هنا أننا نقوم بالبحث بالعمق أولا أي أننا نقوم بالمرور على الحالات ونقوم بإضافتها ضمن stack حتى الوصول إلى نهاية المسار وعندها نبدأ بالحذف أي first in last out 
الحل: يقوم تابع dfs_solve بإعادة list تحوي solutions نستفيد منها في طباعة الحل


